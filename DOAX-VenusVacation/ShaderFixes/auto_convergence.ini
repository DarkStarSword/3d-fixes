[Constants]
; Set to 1 to enable auto-convergence:
global persist $auto_convergence_enabled = 1

; Minimum convergence for auto-convergence:
global $min_convergence = 0.5

; Soft maximum convergence for auto-convergence (before popout bias):
global $max_convergence_soft = 4.0

; Hard maximum convergence for auto-convergence (after popout bias):
global $max_convergence_hard = 20.0

; Popout bias. Sets how far out of the screen auto-convergence will aim to
; position the closest object, and tries to do so in a way that works pretty
; well regardless of the scene, screen size or viewing distance. 0.0 is screen
; depth, -1 is infinity. A small positive value usually works pretty well. The
; auto-convergence HUD will display this value while adjusting convergence
; TODO: Make persistant once certain nothing can mess it up
global $ini_popout_bias = 0.00

; Rate for the slow auto-convergence transition (convergence change per second):
global $slow_convergence_rate = 0.5

; Amount the convergence is allowed to get *closer* than the auto-convergence
; target before the slower auto-adustment kicks in:
global $slow_convergence_threshold_near = 0.0

; Amount the convergence is allowed to get further than the auto-convergence
; target before the slower auto-adustment kicks in:
global $slow_convergence_threshold_far = 0.1

; If the convergence gets at least this far out in either direction an instant
; correction will be triggered. Set to 0 to lock auto-convergence on:
global $instant_convergence_threshold = 2.0

; This is the anti-judder threshold - if an object near the camera is pushed
; out of frame due to an auto-convergence adjustment, the auto-convergence will
; no longer see it and may start shaking the convergence between two values. The
; auto-convergence shader tries to counter this, by detecting if it is trying
; to set the convergence back to what it just was a moment ago and stopping.
; This value defines how close the convergence can be to the previous value to
; trigger this detection. Set to 0 to disable this countermeasure:
global $anti_judder_threshold = 0.1

; Number of seconds the auto-convergence HUD is displayed after adjusting the
; convergence via hotkey:
global $auto_convergence_hud_timeout = 2.0

; Display a notice if the auto-convergence shader did not receive a Z-buffer:
global $warn_no_z_buffer = 0

; Internal state, do not edit:
global $prev_convergence
global $prev_stereo_active
global $prev_time

[Present]
; This custom shader will automatically adjust the convergence to try to keep
; the game comfortable to look at no matter how the camera changes. Check the
; [Constants] section for some ways to tune this to your liking, or comment
; this out to disable it altogether if you prefer manual convergence:

if stereo_active
	; TODO: Move some of the control logic out of the shader to here
	local $bak_x1 = x1
	local $bak_y1 = y1
	local $bak_z1 = z1
	local $bak_w1 = w1

	local $bak_x2 = x2
	local $bak_y2 = y2
	local $bak_z2 = z2
	local $bak_w2 = w2

	local $bak_x3 = x3
	local $bak_y3 = y3
	local $bak_z3 = z3
	local $bak_w3 = w3

	local $bak_x4 = x4
	local $bak_y4 = y4
	local $bak_z4 = z4
	local $bak_w4 = w4

	x1 = $min_convergence
	y1 = $max_convergence_soft
	z1 = $max_convergence_hard
	w1 = $ini_popout_bias

	x2 = $slow_convergence_rate
	y2 = $slow_convergence_threshold_near
	z2 = $slow_convergence_threshold_far
	w2 = $instant_convergence_threshold

	;x3 = time
	y3 = $prev_time
	z3 = $prev_convergence
	w3 = $anti_judder_threshold

	x4 = $auto_convergence_hud_timeout
	y4 = $auto_convergence_enabled
	z4 = $warn_no_z_buffer
	w4 = $prev_stereo_active

	;if $auto_convergence_enabled
		run = CustomShaderAutoConvergence
	;endif
	run = CustomShaderAutoConvergenceHUD

	x1 = $bak_x1
	y1 = $bak_y1
	z1 = $bak_z1
	w1 = $bak_w1

	x2 = $bak_x2
	y2 = $bak_y2
	z2 = $bak_z2
	w2 = $bak_w2

	x3 = $bak_x3
	y3 = $bak_y3
	z3 = $bak_z3
	w3 = $bak_w3

	x4 = $bak_x4
	y4 = $bak_y4
	z4 = $bak_z4
	w4 = $bak_w4
endif

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; AUTO CONVERGENCE ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This implements a depth-buffer based auto-convergence system. The depth
; buffer is sampled in a number of places and downscaled to find the nearest
; point to the camera on screen. A shader (auto_convergence.hlsl) then uses
; this value to calculate an appropriate convergence value to use for the
; current scene, and the result will be used in the next+1 frame.
;
; Remember to use StereoFlagsDX10 = 0x00000008 so that this takes the left eye
; into account in SLI - it will still work without that, but won't be as good.

[Key Toggle Auto Convergence]
key = ~
$auto_convergence_enabled = 0, 1
type = cycle

; A bunch of downsampled depth buffers:
[ResourceAutoConvergenceDepthDownscale128]
width = 128
height = 128
format = R32_FLOAT
mode = stereo
[ResourceAutoConvergenceDepthDownscale64]
width = 64
height = 64
mode = stereo
[ResourceAutoConvergenceDepthDownscale32]
width = 32
height = 32
mode = stereo
[ResourceAutoConvergenceDepthDownscale16]
width = 16
height = 16
mode = stereo
[ResourceAutoConvergenceDepthDownscale8]
width = 8
height = 8
mode = stereo
[ResourceAutoConvergenceDepthDownscale4]
width = 4
height = 4
mode = stereo
[ResourceAutoConvergenceDepthDownscale2]
width = 2
height = 2
mode = stereo
[ResourceAutoConvergenceDepthDownscale1]
width = 1
height = 1
mode = stereo

[ResourceAutoConvergence]
; Buffer to hold the new convergence value, which will be transferred from the
; GPU back to the CPU and will be set to the convergence in some future frame.
type = Buffer
format = R32_FLOAT
array = 1

[ResourceAutoConvergenceState]
; This buffer holds some state that the auto-convergence shader uses to try to
; counter unwanted judder in some (literal) edge cases, and other things.
type = RWStructuredBuffer
;
; data= sets the initial state of the buffer - the size of the buffer is
; automatically calculated from this, offering an alternative to manually
; specifying stride and array - for a structured buffer stride will be set to
; the buffer size, and array will be 1.
;
; Specifying the format inline here instead of in a separate format= line makes
; it only apply to parsing this line, leaving the actual buffer format as
; UNKNOWN, which is necessary for structured buffers.
;
; Pass hex literalls for parameters that aren't floats, e.g. You can stop the
; auto-convergence HUD from showing up on launch by changing the initial state
; of prev_auto_convergence_enabled (8th field, a boolean) to 0xffffffff.
;
; 0x7fc00000 is "nan", signifying that 3DMigoto did not set the convergence
; last frame. When we switch 3DMigoto to the vs2015 branch we will be able to
; just write "nan" here instead.
data = R32_FLOAT 0 0 0 0 0 0 0 0x00000000 0 0x7fc00000

[CustomShaderAutoConvergenceInitialDownscale]
; Description below where this is called
ps = ShaderFixes/downscale_coarse.hlsl
Draw = 4, 0

[CustomShaderAutoConvergenceIntermediateDownscale]
; Description below where this is called
ps = ShaderFixes/downscale_mono_half_max.hlsl

ResourceAutoConvergenceDepthDownscale64 = copy_desc ResourceAutoConvergenceDepthDownscale128
o0 = set_viewport ResourceAutoConvergenceDepthDownscale64
ps-t110 = ResourceAutoConvergenceDepthDownscale128
Draw = 4, 0
;post ResourceDebug2D = ResourceAutoConvergenceDepthDownscale64

ResourceAutoConvergenceDepthDownscale32 = copy_desc ResourceAutoConvergenceDepthDownscale128
o0 = set_viewport ResourceAutoConvergenceDepthDownscale32
ps-t110 = ResourceAutoConvergenceDepthDownscale64
Draw = 4, 0
;post ResourceDebug2D = ResourceAutoConvergenceDepthDownscale32

ResourceAutoConvergenceDepthDownscale16 = copy_desc ResourceAutoConvergenceDepthDownscale128
o0 = set_viewport ResourceAutoConvergenceDepthDownscale16
ps-t110 = ResourceAutoConvergenceDepthDownscale32
Draw = 4, 0
;post ResourceDebug2D = ResourceAutoConvergenceDepthDownscale16

ResourceAutoConvergenceDepthDownscale8 = copy_desc ResourceAutoConvergenceDepthDownscale128
o0 = set_viewport ResourceAutoConvergenceDepthDownscale8
ps-t110 = ResourceAutoConvergenceDepthDownscale16
Draw = 4, 0
;post ResourceDebug2D = ResourceAutoConvergenceDepthDownscale8

ResourceAutoConvergenceDepthDownscale4 = copy_desc ResourceAutoConvergenceDepthDownscale128
o0 = set_viewport ResourceAutoConvergenceDepthDownscale4
ps-t110 = ResourceAutoConvergenceDepthDownscale8
Draw = 4, 0
;post ResourceDebug2D = ResourceAutoConvergenceDepthDownscale4

ResourceAutoConvergenceDepthDownscale2 = copy_desc ResourceAutoConvergenceDepthDownscale128
o0 = set_viewport ResourceAutoConvergenceDepthDownscale2
ps-t110 = ResourceAutoConvergenceDepthDownscale4
Draw = 4, 0
;post ResourceDebug2D = ResourceAutoConvergenceDepthDownscale2

ResourceAutoConvergenceDepthDownscale1 = copy_desc ResourceAutoConvergenceDepthDownscale128
o0 = set_viewport ResourceAutoConvergenceDepthDownscale1
ps-t110 = ResourceAutoConvergenceDepthDownscale2
Draw = 4, 0
;post ResourceDebug2D = ResourceAutoConvergenceDepthDownscale1

[CustomShaderAutoConvergence]
vs = ShaderFixes/full_screen.hlsl
blend = disable
cull = none
topology = triangle_strip
run = CommandListUnbindAllRenderTargets

; Initial pass samples points on the depth buffer to downscale it to a fixed
; size, regardless of the original depth buffer size. This will have severe
; aliasing, and is not intended to be displayed graphically. Calling this
; custom shader from here to inherit common state:
ResourceAutoConvergenceDepthDownscale128 = copy_desc ResourceDepthBuffer
o0 = set_viewport ResourceAutoConvergenceDepthDownscale128
ps-t110 = ResourceDepthBuffer
run = CustomShaderAutoConvergenceInitialDownscale
;post ResourceDebug2D = ResourceAutoConvergenceDepthDownscale128

; Intermediate passes just combine the samples we have into a progressively
; smaller buffer. Calling this from here inherits common state, and this shader
; section will call Draw() multiple times for each progressive downscale step:
run = CustomShaderAutoConvergenceIntermediateDownscale

; The final pass is run from the context of this custom shader. This takes the
; downscaled buffers from both eyes and implements the actual auto-convergence
; logic to determine the new convergence value:
ps = ShaderFixes/auto_convergence.hlsl
ps-cb13 = Resource_gGlobalParam
post ps-cb13 = null
o0 = ResourceAutoConvergence
ps-u1 = ResourceAutoConvergenceState
ps-t110 = stereo2mono ResourceAutoConvergenceDepthDownscale1
; FIXME: We should set the post time to same value we got for pre-time, since
; time can pass between these. We could save the previous time to a custom
; resource with the current capabilities of 3DMigoto, or expand 3DMigoto to
; allow one ini param to be set to another, but this doesn't really seem to
; matter in practice yet, so this will do for now:
pre x3 = time
post $prev_time = time
Draw = 4, 0
;ResourceDebugBuf = ResourceAutoConvergenceState

post ps-t100 = null

; This will asynchronously transfer the new convergence value from the GPU back
; to the CPU, which will then be used in some future frame (not necessarily the
; next frame). Specifying "pre" or "post" is required for this to preserve the
; new convergence, otherwise the old value would be immediately restored at the
; end of the custom shader. This is due to the way that 3DMigoto historically
; handled per-shader convergence:
if $auto_convergence_enabled
	post convergence = ResourceAutoConvergence
endif
; Record the convergence set (or not) prior to the present call. We compare
; this to the convergence in the next frame to determine if the user is
; adjusting the convergence, and convert it to an equivalent popout bias:
post $prev_convergence = convergence
post $prev_stereo_active = stereo_active

[ResourceAutoConvergenceFont]
; Note that this font has the size of each character embedded in the unused
; space of the final character, which the geometry shader uses to render each
; character the correct width. This font was generated with gen_bm_font.py,
; then converted to DDS (because our PNG loading seems to be broken o_O):
filename = ShaderFixes\LiberationSans-Bold.dds
[CustomShaderAutoConvergenceHUD]
; The vertex shader passes draw indexes to the geometry shader:
vs = ShaderFixes/auto_convergence_hud.hlsl
; The geometry shader generates the text for a given draw index:
gs = ShaderFixes/auto_convergence_hud.hlsl
; The pixel shader draws the font:
ps = ShaderFixes/auto_convergence_hud.hlsl
; Allows us to use SV_Position.z to pack a texcoord, increasing the character
; limit per geometry shader invocation:
depth_clip_enable = false
cull = none
; Enable alpha blending. To change the text colour, edit the pixel shader:
blend = add one inv_src_alpha
; Use points as the primitive from the vertex shader to the geometry shader:
topology = point_list
run = CommandListUnbindAllRenderTargets
o0 = set_viewport no_view_cache bb
; Pass the auto-convergence state to the geometry shader:
gs-t113 = ResourceAutoConvergenceState
post gs-t113 = null
; Font is passed into the pixel shader (to draw it) *and* the geometry shader
; (as the character sizes are encoded in the final character of the font):
gs-t100 = ResourceAutoConvergenceFont
ps-t100 = ResourceAutoConvergenceFont
post gs-t100 = null
post ps-t100 = null
; Change this number to set how many lines of text may be drawn:
draw = 1, 0
